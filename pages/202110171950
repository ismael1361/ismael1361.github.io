#[Mapeando um quadrado para um c√≠rculo](./?page=archive&id=202110171950)

*17 - Out, 2021*

Em um momento de curiosidade explorando pela plataforma de YouTube, me deparei com artes em ilustra√ß√£o e algo me chamou muita aten√ß√£o em meio de tantos conte√∫dos (que ali√°s, todos que encontrei s√£o incrivelmente encantadores), que foi a ferramenta de pigmento de cores HSV em um formato de disco num aplicativo para iOS chamado Procreate, como mostrado nesta imagem abaixo:

![Procreate - Paleta HSV em disco](./pages/assets/images/202110171950/002.jpg =350x350)

Como programador, pensei em introduzir algo semelhante usando JavaScript, a primeira coisa que fiz foi procurar por algum projeto desse tipo no GitHub. Ap√≥s muitas pesquisas, encontrei o projeto [color-disc](https://github.com/afternoon2/color-disc) de [Jakub Antolak](https://github.com/afternoon2) com as mesmas inten√ß√µes, mas, n√£o atendeu as expectativas, pois havia uma falha bem not√°vel ao brincar um pouco com a demonstra√ß√£o no [codepen.io](https://codepen.io/jakub_antolak/pen/LKxzpJ). O erro surgiu quando tive a necessidade de chegar at√© a cor absoluta da tonalidade (hue), o branco ou at√© mesmo o preto. Analisando o c√≥digo fonte, percebi que a perspectiva estava como uma grade retangular e n√£o em um espa√ßo circular, como deveria ser.

![Grade retangular para um espa√ßo circular](./pages/assets/images/202110171950/005.png)

Logo procurei corrigir esse erro, comecei a pensar de uma forma que introduzisse o mesmo efeito como a do Procreate (j√° que este √© o nosso objetivo) e pensei em um tipo de c√°lculo de mapeamento que convertesse uma grade retangular para um espa√ßo circular.

Imagine uma situa√ß√£o trabalhando com um controlador de jogo, voc√™ espera que as coordenadas do joystick sejam circulares. Na realidade, voc√™ obt√©m as informa√ß√µes de dois eixos separados, que se estendem por um quadro de coordenadas retangulares, ent√£o, voc√™ precisa analisar em como derivar uma maneira de mapear uma grade retangular para um espa√ßo circular como este exemplo:

![Grade retangular para um espa√ßo circular](./pages/assets/images/202110171950/001.png)

Mas na verdade, por tr√°s desse esquema existe uma equa√ß√£o matem√°tica que ser√° bem √∫til para o nosso objetivo. Essas equa√ß√µes podem ser encontradas neste [link](https://marc-b-reynolds.github.io/math/2017/01/08/SquareDisc.html) e nesse [artigo em PDF](https://arxiv.org/pdf/1709.07875.pdf). Mas iremos focar em apenas uma equa√ß√£o, que observando bem, seria algo semelhante ao do Procreate.

##Deriva√ß√£o
####Explicando a equa√ß√£o

Pense em apenas um c√≠rculo unit√°rio, pois qualquer generaliza√ß√£o √© apenas uma escala da equa√ß√£o resultante posteriormente. Isso significa que um ponto \\((x, e)\in P\\) √© definido por:

\\[P = \\{(x, y) | x, e\in [-1, 1]\\}\\]

A forma como o mapeamento funciona √© pensar em uma linha de constante \\(x\\) bem como uma linha de constante \\(e\\), que √© mapeado para uma elipse. Isso significa que temos um requisito para ser verdadeiro, dado pela equa√ß√£o da elipse para uma constante \\(x\\):

\\[1 = \dfrac{x'^2}{x^2} + \dfrac{x'^2}{c^2}\\]

Para garantir que todos os pontos ao longo da curva no topo do c√≠rculo sejam atingidos, precisamos ter certeza de que para qualquer \\(x \in [‚àí1,1]\\) a elipse passa pelo ponto

\\[(x', y') = \left(\frac{x}{\sqrt{2}}, \sqrt{1-\frac{x^2}{2}}\right)\\]

Conectar este ponto √† primeira equa√ß√£o nos d√° o coeficiente \\(c\\) para a elipse:

\\[\begin{array}{rrl}&amp; 1 &amp; = \frac{\frac{x^2}{2}}{x^2} + \frac{1-\frac{x^2}{2}}{c^2}\\\ \Leftrightarrow &amp; \frac{c^2}{2} &amp; = 1 - \frac{x^2}{2}\\\ \Leftrightarrow &amp; c &amp; = \sqrt{2 -x^2}\end{array}\\]

Para uma constante \\(x\\) a elipse √© assim:

\\[1 = \frac{x'^2}{x^2} + \frac{y'^2}{2-x^2}\\]

Da mesma forma, podemos resolver para uma constante \\(e\\) e pegue a elipse:

\\[1 = \frac{x'^2}{2-y^2} + \frac{y'^2}{y^2}\\]

Resolvendo para \\(x'^2\\) n√≥s temos:

\\[\begin{array}{rrl}&amp; 1 - \frac{y'^2}{2-x^2} &amp; = \frac{x'^2}{x^2}\\\ \Leftrightarrow &amp; x'^2 &amp; = x^2 \left(1-\frac{y'^2}{2-x^2}\right)\end{array}\\]

Conectar isso √† segunda equa√ß√£o resulta em

\\[\begin{array}{rrl}&amp; 1 &amp; = \frac{x^2\left(1-\frac{y'^2}{2-x^2}\right)}{2-y^2} + \frac{y'^2}{y^2}\\\ \Leftrightarrow &amp; y^2(2-y^2)(2-x^2) &amp; = x^2y^2(2-x^2-y'^2)+y'^2(2-y^2)(2-x^2)\\\ \Leftrightarrow &amp; y'^2 &amp; = y^2\frac{(2-x^2)(2-y^2-x^2)}{(2-x^2)(2-y^2)-x^2y^2}\\\ &amp; &amp; = y^2\frac{(2-x^2)(2-y^2-x^2)}{4-2x^2-2y^2}\\\ &amp; &amp; = y^2\left(1-\frac{x^2}{2}\right)\\\ \Leftrightarrow &amp; y' &amp; = y\sqrt{1-\frac{x^2}{2}}\end{array}\\]

Usando simetria, obtemos o mapeamento de um quadrado no intervalo -1 a 1, para as coordenadas \\(x\\) e \\(y\\) para um c√≠rculo unit√°rio. Como dito antes, resolver o caso geral √© simplesmente normalizar para um quadrado no tamanho certo e dimensionar o resultado novamente depois.

\\[(x', y') = \left(x\sqrt{1-\frac{y^2}{2}}, y\sqrt{1-\frac{x^2}{2}}\right)\\]

##C√≥digo JavaScript

Uma fun√ß√£o JavaScript que mapeia um ponto retangular para um espa√ßo circular unit√°rio pode ser implementada assim:

```js
function square_to_disc(x, y){
    return [
        x * Math.sqrt(1 - y * y / 2), 
        y * Math.sqrt(1 - x * x / 2)
    ];
}
```

Para inverter de um espa√ßo c√≠rculo para coordenadas retangular, pode ser implementada assim:

```js
function disc_to_square(u, v){
    let u2 = u * u,
        v2 = v * v,
        r2 = u2 + v2;

    if(r2 > 1){return;}  //caso se estiver fora do disco

    let twosqrt2 = 2.0 * Math.sqrt(2.0),
        subtermx = 2.0 + u2 - v2,
        subtermy = 2.0 - u2 + v2,
        termx1 = subtermx + u * twosqrt2,
        termx2 = subtermx - u * twosqrt2,
        termy1 = subtermy + v * twosqrt2,
        termy2 = subtermy - v * twosqrt2;

    return [
        x = 0.5 * Math.sqrt(termx1) - 0.5 * Math.sqrt(termx2),
        y = 0.5 * Math.sqrt(termy1) - 0.5 * Math.sqrt(termy2)
    ];
}
```

Os valores devem ser passados entre ou igual a -1 e 1. Quanto mais pr√≥ximo de -1; mais pr√≥ximo do canto inferior esquerdo e quanto mais pr√≥ximo de 1; mais pr√≥ximo do canto superior direito, da mesma forma serve para um espa√ßo circular. Agora, seguindo numa l√≥gica HSV (tonalidade, satura√ß√£o e valor), podemos dizer que quanto mais pr√≥ximo de -1; menor √© a satura√ß√£o e valor e quanto mais pr√≥ximo de 1; maior √© a satura√ß√£o e valor.

Agora, vamos aplicar esses conceitos realizando um exemplo de rasteriza√ß√£o utilizando o Canvas:

```html
<canvas id="main-canvas" width="400" height="400"/>
```

De princ√≠pio iremos utilizar as dimens√µes de um quadrado de 400x400. No JavaScript vamos rasterizar por toda √°rea do Canvas, pixel por pixel: 

```js
let c = document.getElementById("main-canvas"),
    ctx = c.getContext("2d");

let image_data = ctx.getImageData(0, 0, c.width, c.height);

for(let i = 0; i < image_data.data.length; i += 4){
    let y = Math.floor((i/4)/c.width),
        x = (i/4)-(y*c.width);

    let color = HSVtoRGB(0, (x/c.width), ((c.height - y)/c.height));

    image_data.data[i + 0] = color[0];
    image_data.data[i + 1] = color[1];
    image_data.data[i + 2] = color[2];
    image_data.data[i + 3] = 255;
}

ctx.putImageData(image_data, 0, 0);
```

Para a convers√£o de HSV para RGB, utilize:

```js
function HSVtoRGB(h, s, v){
    var r, g, b, i, f, p, q, t;
    if(arguments.length === 1){
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch(i % 6){
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
    ];
}
```

Assim, teremos esse resultado:

![Exemplo 1](./pages/assets/images/202110171950/003.png =350x350)

Agora, para adquirir as coordenadas de mapeamento retangular para circular, primeiro devemos recapturar a l√≥gica, j√° que temos que ter em m√£os apenas os valores entre ou iguais a -1 e 1. Mas como fazer isso com uma coordenada de \\(x\\) e \\(y\\) assim como no c√≥digo que fizemos para rasterizar toda a √°rea do Canvas? üßê

Na verdade, existem v√°rias solu√ß√µes, vejamos um exemplo de uma coordenada \\(x\\). Subtraia \\(x\\) pela largura da √°rea dividida por 2 e com o resultado, divida por esta mesma largura. Fa√ßa o mesmo com o \\(y\\), s√≥ que ao inv√©s de ser com a largura, ser√° com a altura. Assim teremos resultados que precisamos para o mapeamento.

\\[(x, y) = \left(\frac{x-\frac{width}{2}}{\frac{width}{2}}, \frac{y-\frac{height}{2}}{\frac{height}{2}}\right)\\]

Agora, para converter de -1 a 1 para 0 a 1, some o valor por mais 1 e divida por 2:

\\[(u, v) = \left(\frac{u+1}{2}, \frac{v+1}{2}\right)\\]

Seguindo nesse conceito, o c√≥digo ficaria desta forma:

```js
...

    let color = [255, 255, 255]; //cor padr√£o de fora do disco

    let mapping = disc_to_square((x - (c.width/2))/(c.width/2), (y - (c.height/2))/(c.height/2));

    if(Array.isArray(mapping)){ //para caso se estiver dentro do disco
        let u = mapping[0],
            v = mapping[1];

        color = HSVtoRGB(0, (u + 1)/2, 1 - ((v + 1)/2));
    }

...
```

Assim, teremos esse resultado:

![Exemplo 1](./pages/assets/images/202110171950/004.png =350x350)

Com esse esquema, podemos afirmar que temos agora algo mais parecido com a do Procreate. Pois olhe bem, agora temos acesso a cor absoluta da tonalidade (hue), o branco e at√© mesmo o preto. Problema resolvido ent√£o, n√£o concorda?

####Exemplo:

* [square2disc - contrariwise](https://codepen.io/ismaelexperiments/pen/dyzGgBV)
* [Color Wheel](https://codepen.io/ismaelexperiments/full/BMydKo)

####Refer√™ncias e fontes:

* ["color-disc", Jakub Antolak, 13/11/2021](https://github.com/afternoon2/color-disc)
* [Jakub Antolak, 13/11/2021](https://github.com/afternoon2)
* ["Square/Disc mappings", Marc B. Reynolds, 08/01/2017](https://marc-b-reynolds.github.io/math/2017/01/08/SquareDisc.html)
* ["Elliptification of Rectangular Imagery", Joint Mathematics Meetings 2019, SIGMAA-ARTS](https://arxiv.org/pdf/1709.07875.pdf)